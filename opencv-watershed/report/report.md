---
title: 实验报告
institution: 人工智能与自动化学院
author: 王迪
class: AI2303
tutor: 韩守东
date: 2025-05-19
toc: false
geometry: left=2cm,right=2cm,top=2.5cm,bottom=2.5cm
fig_pos: H
---
# 实验报告

## 封面

![HUST](image/HUST.jpg)

![AIA](image/AIA.jpg)

- 学校和学院LOGO
- 报告标题
- 院系
- 专业和班级
- 学号
- 姓名
- 指导老师
- 提交时间

## 目录

1. [问题描述](#问题描述)
2. [算法设计](#算法设计)
3. [测试分析](#测试分析)
4. [总结展望](#总结展望)
5. [附录](#附录)

## 问题描述

### 实验任务

<!-- 详细描述需要完成的任务。 -->

开发程序实现以下功能

输入：任意一张M*N的彩色图片

使用OpenCV库，使用纯C语言或者C/C++语言

### 任务一 均匀随机采样

使用基于种子标记的分水岭算法（OpenCV自带watershed）对输入图像进行过分割

用户输入图像和整数K，要求程序自动计算K个随机种子点，确保各种子点之间的距离均 > (M*N/K)0.5（参考泊松圆盘采样+贪心策略）

然后让程序在原图中标出各种子点的位置及编号，并采用半透明+随机着色的方式给出分水岭算法的可视化结果

### 任务二 四原图着色

使用邻接表统计分水岭结果中各区域的邻接关系

并采用四原色法（合理选择初始着色区域，并基于图的广度优先遍历，采用队列对其他待着色区域进行着色顺利梳理，加速全图着色过程）

对分水岭结果重新着色（使用堆栈+回溯策略，优化回退率）

### 任务三 排序查找+哈夫曼

根据分水岭结果中各区域面积大小的“堆排序”结果，提示最大和最小面积，

用户输入查找范围（面积下界和上界），使用折半查找，程序对所有符合要求的分水岭结果（标记区域面积）进行突出显示

并以这些高亮区域的面积大小作为权值，进行哈夫曼编码（考虑深度+递归策略），绘制该哈夫曼树

### 规范要求

实验的指导方针和约束条件。

- 学习使用STL标准模板库和OpenCV基本数据格式
- 少用静态数组，多用指针和动态内存分配/释放
- 对源码中文件、函数进行合理划分，保证模块独立性
- 函数、变量、常量等命名规范（去汉语拼音）
- 文件、函数宏观注释，核心变量、程序段微观注释
- 对输入进行合法性校验和功能、容错提示
- 尽量优化算法，确保稳定性及低时空复杂度
- 设计和优化Demo的交互逻辑及可视化UI

### 编程环境

开发所使用的工具和平台。

```txt
OS: Kubuntu 24.04.2 LTS x86_64 
vscode 1.97.2
opencv 4.12.0-dev
```

<!-- Host: 21LE ThinkBook 16 G6+ IMH 
Kernel: 6.11.0-17-generic 
DE: Plasma 5.27.12 
CPU: Intel Ultra 9 185H (22) @ 4.800GHz 
GPU: NVIDIA GeForce RTX 4060 Max-Q / Mobile 
GPU: Intel Arc Graphics -->

### 测试数据

fruits.jpg... in image/

### 评价指标

<!-- 评估算法性能的标准。 -->


> 对于 600*600 左右分辨率的图片，在基本任务（数据结构和算法）和功能（提示、交互逻辑及可视化 UI）都能实现的前提下，给出如下分类评价，介于其间较远者，给出对应的“+”或“-”评价结论；如果基本要求都没有实现或者实现不够完整，该任务不予验收：
>
> 任务 1：均匀随机采样 
>
> A  K=1000 时，产生的随机点数大于 1000，程序用时 1s 以内
>
> B  K=500 时，产生的随机点数大于 500，程序用时 0.5s 以内
>
> C  K=100 时，产生的随机点数大于 100，程序用时 0.2s 以内
>
> 任务 2：四原图着色
>
> A  K=1000 时，失败率低于 40%，程序用时 4s 以内
>
> B  K=500 时，失败率低于 20%，程序用时 2s 以内
>
> C  K=100 时，失败率低于 10%，程序用时 0.5s 以内
>
> 任务 3：排序查找+哈夫曼
>
> A  K=1000 时，用时 1s 以内，完成折半查找和递归哈夫曼编码，可视化符合要求，其中哈夫曼树的绘制，满足深度右倾、横向分布均匀、编码标记清晰
>
> B  K=500 时，用时 0.5s 以内，完成折半查找和递归哈夫曼编码，可视化、容错处理、相关信息提示效果尚可
>
> C  K=100 时，用时 0.1s 以内，完成折半查找和递归哈夫曼编码，可视化、容错处理、相关信息提示效果不够清晰美观
>

## 算法设计

### 破题原理分析
// agent start
<!-- 解释基本原理和理论。 -->

基于opencv框架和既有的demo程序
分布实现三个任务

task1
使用 jittered hex grid sample // explain
首先构建六边形网格作为框架，因六边形法理论上采样点上限最高
再随机采样K种子点

task2
运用四原色法
采用队列
对分水岭结果重新着色
// explain

task3
对区域面积进行堆排序
构建哈夫曼树，可视化
// explain

### 整体架构设计

系统架构的高层设计。

以鼠标绘制分水岭demo程序为基础
分别编写task1/2/3对应程序
每个任务的特定功能和算法，在不同的文件分别实现
多个任务需要用到的功能，在一个文件里共用
项目使用make构建
最终在build文件夹得到可执行程序

```txt
├── build                   // executable program
├── cv2-watershed-copy.cpp  // original demo program
├── doc
├── image                   // input image
│   └── fruits.jpg
├── Makefile                // compile project
├── sample.h                // sampling
├── task1.cpp               // task1 program
├── task2.cpp               // task2 program
├── task3.cpp               // task3 program
└── watershed_utils.h       // common utils, helper functions
```

### 算法逻辑设计

<!-- 详细的算法逻辑设计。 -->

#### task1

// write

#### task2

任务二的核心目标是利用四色定理对分水岭算法分割出的区域进行着色。算法主要包含以下步骤：

1. **邻接关系构建**：
   - 遍历分水岭算法输出的标记矩阵（`markers`图像）。对于每个像素，检查其四邻域或八邻域像素。
   - 如果相邻像素属于不同的分割区域（即具有不同的标记ID），则记录这两个区域是相邻的。
   - 为避免重复记录和方便查询，使用邻接表（如 `std::vector<std::set<int>>`）来存储区域间的邻接关系。每个区域ID对应一个集合，集合中存储所有与之相邻的区域ID。

2. **图着色算法**：
   - **初始化**：准备四种颜色（例如，编号0, 1, 2, 3）。创建一个数组或映射来存储每个区域的颜色，初始时所有区域均未着色。
   - **着色顺序与策略**：
     - 可以从一个未着色的区域开始（例如，选择面积最大或邻居最多的区域作为起点，或者简单地从区域0开始）。
     - 采用广度优先搜索（BFS）的策略来决定区域的着色顺序。将起始区域加入队列。
   - **颜色分配与冲突处理**：
     - 当从队列中取出一个区域时，尝试为其分配一种有效颜色。一种颜色是有效的，如果它没有被任何已着色的相邻区域使用。
     - 遍历四种预定义颜色，选择第一个满足条件的颜色。
     - 如果当前区域无法使用任何可用颜色（即所有四种颜色均已被其相邻区域占用），则表明之前的颜色选择导致了冲突。
   - **回溯机制**：
     - 为了处理着色冲突并优化成功率，引入回溯策略。这通常通过递归函数实现，其中维护当前着色状态。
     - 如果一个区域无法被着色，算法会回溯到前一个（或相关的）已着色区域，尝试为该区域分配另一种不同的有效颜色，然后再次尝试为后续区域着色。
     - 可以使用栈（显式或通过递归调用栈隐式实现）来管理决策点，以便在发生冲突时能够有效地回退和尝试其他颜色组合。
   - **迭代**：将新着色的区域的未着色邻居加入队列，并继续该过程，直到所有区域都被成功着色或所有可能性都已尝试。

该方法结合了BFS的有序遍历和回溯的灵活性，旨在高效地找到一个有效的四色方案。

#### task3

任务三旨在对分水岭算法分割得到的区域，根据其面积进行分析和编码。主要步骤如下：

1. **区域面积统计与排序**：
   - 遍历分水岭算法输出的标记矩阵（`markers`图像），计算每个独立分割区域的面积（即像素数量）。将区域ID与其对应的面积存储起来，例如使用 `std::vector<std::pair<int, int>>`，其中每个元素是 `{区域ID, 面积}`。
   - 使用堆排序算法（Heap Sort）对所有区域按面积进行升序或降序排序。堆排序能保证较好的平均和最坏情况时间复杂度（O(n log n)）。
   - 排序后，程序应能直接获取并提示面积最大和最小的区域及其面积值。

2. **基于面积范围的区域查找与高亮**：
   - 用户输入一个面积范围，包括下界（min_area）和上界（max_area）。
   - 在已按面积排序的区域列表中，使用折半查找（Binary Search，或利用 `std::lower_bound` 和 `std::upper_bound`）高效地找到所有面积在此范围内的区域。
   - 程序将这些符合条件的区域在图像上进行突出显示，例如使用特定的颜色或叠加半透明蒙版。

3. **哈夫曼编码与树的可视化**：
   - 将上一步筛选出的、面积在指定范围内的区域的面积大小作为权值（频率）。
   - 基于这些权值构建哈夫曼树（Huffman Tree）。构建过程通常使用优先队列（最小堆）实现：
     1. 为每个区域（权值）创建一个叶节点。
     2. 将所有叶节点加入优先队列。
     3. 当队列中有多于一个节点时，重复以下操作：
        - 从队列中取出两个权值最小的节点（作为左右子节点）。
        - 创建一个新的内部节点，其权值为这两个子节点权值之和。
        - 将新节点加入优先队列。
     4. 队列中最后剩下的节点即为哈夫曼树的根节点。
   - **哈夫曼编码生成**：从根节点开始，递归遍历哈夫曼树。向左子树的路径分配编码 '0'，向右子树的路径分配编码 '1'。到达叶节点时，所经过的路径编码即为该叶节点对应区域的哈夫曼编码。
   - **哈夫曼树可视化**：
     - 将构建的哈夫曼树结构输出为 DOT 语言格式的文本文件。
     - 调用 Graphviz 工具（如 `dot` 命令）将 DOT 文件转换为图像格式（如 PNG），从而实现哈夫曼树的可视化。
     - 可视化时需注意树的布局，确保深度右倾、横向分布均匀，并且节点上清晰标记区域ID、面积及生成的哈夫曼编码。

该流程结合了高效的排序、查找算法以及经典的哈夫曼编码技术，实现了对图像分割区域的多维度分析和信息压缩表示。

### 数据结构设计

本项目在实现各项功能时，主要利用了以下数据结构：

1.  **`cv::Mat` (OpenCV 矩阵)**：
    *   **用途**：存储和操作图像数据（原始图像、灰度图像、标记矩阵 `markers`、分水岭结果可视化图像 `wshed` 等）。OpenCV的核心数据结构，用于高效处理像素数据。
    *   **说明**：`markers` 矩阵尤为重要，它是一个与原图等大的单通道32位整型矩阵（`CV_32S`），其中每个像素值代表其所属的分割区域ID（0通常表示背景或未定义，-1表示分水岭边界，正数表示具体的区域标签）。

2.  **`std::vector<cv::Point>` (点向量)**：
    *   **用途**：存储种子点坐标（Task 1）。`cv::Point` 是OpenCV中表示二维坐标点（x, y）的结构。

3.  **`std::vector<std::vector<int>>` 或 `std::vector<std::set<int>>` (邻接表)**：
    *   **用途**：表示区域间的邻接关系（Task 2）。
    *   **`std::vector<std::vector<int>>`**：外层vector的索引代表区域ID，内层vector存储该区域所有邻接区域的ID。可能存在重复邻接关系，查询特定邻接关系效率较低。
    *   **`std::vector<std::set<int>>`**：更优选择。外层vector索引代表区域ID，内层 `std::set` 存储邻接区域ID，自动去重且方便查找（O(log N)）。

4.  **`std::vector<int>` (颜色向量/状态向量)**：
    *   **用途**：存储每个区域分配到的颜色（Task 2，索引为区域ID，值为颜色编号）或记录区域的访问状态（如图着色过程中的已访问、未访问）。

5.  **`std::queue<int>` (队列)**：
    *   **用途**：实现广度优先搜索（BFS）算法，用于图着色过程中的区域遍历顺序管理（Task 2）。

6.  **`std::stack<State>` (栈)**：
    *   **用途**：实现回溯算法，用于图着色过程中的状态保存与恢复（Task 2）。`State` 可以是一个自定义结构体，包含当前着色进度、已做决策等信息。

7.  **`std::vector<std::pair<int, int>>` (区域面积向量)**：
    *   **用途**：存储每个区域的ID及其对应的面积（Task 3）。`std::pair<int, int>` 中，`first` 可以是区域ID，`second` 是面积，或者反之，根据排序和查找需求决定。

8.  **自定义 `HuffmanNode` 结构体/类 (哈夫曼树节点)**：
    *   **用途**：构建哈夫曼树（Task 3）。
    *   **成员**：
        *   `int label`：区域ID（仅叶节点有效，内部节点可设为-1）。
        *   `int area`：区域面积（作为频率/权值）。
        *   `HuffmanNode *left`：指向左子节点的指针。
        *   `HuffmanNode *right`：指向右子节点的指针。
        *   （可选）`std::string code`：存储该节点（如果是叶节点）的哈夫曼编码。

9.  **`std::priority_queue<HuffmanNode*, std::vector<HuffmanNode*>, CompareNodes>` (优先队列)**：
    *   **用途**：辅助构建哈夫曼树（Task 3）。`CompareNodes` 是一个自定义比较器，用于实现最小堆（按节点面积/权值排序）。

10. **`std::map<int, std::string>` (哈夫曼编码表)**：
    *   **用途**：存储每个区域ID（`int`）到其对应哈夫曼编码（`std::string`）的映射（Task 3）。

11. **`std::vector<cv::Vec3b>` (颜色查找表)**：
    *   **用途**：存储用于可视化分水岭区域的随机颜色或预定义颜色（Task 1, Task 2）。`cv::Vec3b` 表示BGR颜色。

这些数据结构的选择旨在平衡功能实现、效率和OpenCV库的兼容性。

### 创新思路总结

<!-- 实现的创新方法或思路总结。 -->
#### 任务一：均匀随机采样

- **抖动六边形网格采样 (Jittered Hexagonal Grid Sampling)**：摒弃纯粹的随机播种或简单的正交网格采样，本项目创新性地采用六边形网格作为初始采样框架。六边形网格在理论上能以最高的填充效率覆盖二维平面，确保了种子点在初始阶段就具有较好的空间分布均匀性。
- **贪心策略优化最小距离**: 在六边形网格初步采样后，结合贪心算法确保种子点间的最小距离约束（类泊松盘采样思想）。具体而言，从候选点中迭代选择符合最小距离要求的点，若一个点与已选所有种子点的距离均大于阈值 `(M*N/K)^0.5`，则将其加入种子点集。这种方法旨在平衡采样点分布的均匀性、随机性以及计算效率，尤其在K值较大时，能有效避免点堆叠，生成视觉上更自然的采样结果。
- **效率与效果的平衡**：通过预先划分六边形格网，缩小了随机选择的范围，再结合贪心距离检查，相较于纯粹的暴力搜索或复杂的泊松盘生成算法，在保证采样质量的同时，显著提高了生成K个种子点的计算效率。

#### 任务二：四色图着色

- **启发式BFS与回溯优化**：
  - **起始节点选择**：在进行广度优先搜索（BFS）确定着色顺序时，并非随机选取起始区域，而是优先选择图中度数最大（邻接区域最多）的区域开始着色。理论上，优先处理约束最强的节点有助于尽早发现潜在冲突，减少后续的回溯深度。
  - **颜色选择策略**：为区域选择颜色时，尝试维持颜色的使用均衡性，或优先选择使用次数最少的颜色，以期为后续区域保留更多选择。
  - **智能回溯**：当发生着色冲突时，回溯机制不仅是简单地返回上一区域尝试不同颜色，而是可以结合启发式信息，例如优先调整导致冲突的关键区域的颜色，或者尝试改变冲突链条上自由度较高（可选颜色较多）的区域的颜色。
- **邻接关系的高效构建与存储**：使用 `std::vector<std::set<int>>` 作为邻接表的数据结构。`std::set` 自动处理了重复邻接关系（例如，两个区域共享多个边界像素段），并保持邻接ID有序，这有助于调试和某些特定分析，同时也简化了邻接判断逻辑。

#### 任务三：排序查找与哈夫曼编码

- **集成化处理流程与动态可视化**：
  - **一站式数据处理**：将分水岭区域的面积计算、基于面积的堆排序、用户定义范围的高效二分查找、以及针对选中区域面积的哈夫曼编码与树的可视化，整合成一个连贯的操作流程。
  - **动态哈夫曼树生成与美化**：哈夫曼树的构建不仅是算法实现，更注重其可视化效果。程序动态生成Graphviz的DOT语言描述，然后调用Graphviz工具渲染出图像。特别注意了树的布局，使其满足“深度右倾、横向分布均匀、编码标记清晰”的要求，增强了结果的可读性和专业性。
- **高效的区域面积统计与查找**：
  - **单遍面积统计**：通过一次遍历标记矩阵（`markers`图像），即可统计出所有分割区域的精确面积，避免了重复计算。
  - **二分查找优化**：在堆排序后的有序面积列表上，采用二分查找算法来快速定位用户指定面积范围内的区域，显著提高了大规模区域集合下的查找效率。
- **用户交互与反馈**：程序不仅执行算法，还提供了清晰的用户交互提示，如最大最小面积、查找范围输入引导，并对查找到的区域在原图或分割图上进行高亮显示，增强了用户体验。

## 测试分析

### 测试目的

验证程序各个模块及整体功能的正确性、稳定性和性能表现。

### 测试环境

- 操作系统：Kubuntu 24.04.2 LTS x86_64
- 开发工具：vscode 1.97.2
- OpenCV版本：4.12.0-dev
- 测试图像：`image/fruits.jpg`（分辨率约600x600）

### 测试分类

1. **功能测试**：验证各个任务（均匀随机采样、四原图着色、排序查找+哈夫曼）的基本功能是否正常。
2. **性能测试**：评估程序在不同规模（K值、图像尺寸）下的运行时间和资源消耗。
3. **稳定性测试**：长时间运行或对大量数据反复操作，观察程序是否稳定，是否有内存泄漏等问题。
4. **边界情况测试**：输入一些边界值或特殊值，验证程序的健壮性，如K=1、K=M*N、空图像等。
5. **合法性测试**：关注程序对无效输入、异常情况及边界条件的容错能力和处理逻辑。

### 测试用例

#### 3.1 常规测试

常规测试旨在验证程序在典型场景下的基本功能和主要逻辑的正确性。



##### 常规测试 - 任务二：四色图着色


##### 常规测试 - 任务三：排序查找与哈夫曼编码



常规测试的通过是后续更复杂测试的基础，确保了核心功能的稳定可靠。

#### 3.2 性能测试

性能测试主要评估程序在处理大规模数据时的效率和资源消耗情况。



性能测试确保了程序在实际应用中能够高效稳定地运行，满足实时或准实时处理的需求。

#### 3.3 稳定性测试



#### 3.4 边界情况测试



#### 3.5 合法性测试

合法性测试关注程序对无效输入、异常情况及边界条件的容错能力和处理逻辑。

##### 合法性测试 - 任务一：均匀随机采样



##### 合法性测试 - 任务二：四色图着色


##### 合法性测试 - 任务三：排序查找与哈夫曼编码


### 测试结果

<!-- 测试结果的汇总与分析。 -->


## 总结展望

### 总结

本次实验通过对分水岭算法的三项任务实现，深入探讨了图像分割、图着色及数据编码的相关技术。主要收获包括：

1. **均匀随机采样**：通过抖动六边形网格结合贪心策略，实现了对种子点的均匀随机采样，克服了传统随机采样在均匀性和边界适应性上的不足。
2. **四原图着色**：运用四色定理和启发式算法，成功实现了对分水岭结果的快速着色，并通过回溯优化提高了着色成功率。
3. **排序查找与哈夫曼编码**：结合堆排序、折半查找和哈夫曼编码，实现了对分水岭分割区域的高效分析和信息压缩。

### 展望

未来可在以下几个方面继续深入与扩展：

1. **算法优化**：进一步优化各项算法的时间和空间复杂度，尤其是在大规模图像和高K值情况下的表现。
2. **用户体验**：优化程序的交互界面与使用流程，开发统一的图形界面，提升用户体验

通过本次实验，理论知识与实践技能得到了有效结合，尤其是在图像处理算法的实现与优化方面。期望在今后的学习与研究中，能够继续深入探索相关领域的前沿技术与应用。